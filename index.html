<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Solar Eclipse Simulation with Umbra and Penumbra + Ring of Fire</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #001020 10%, #000000 100%);
      font-family: Arial, sans-serif;
      color: white;
    }
    canvas { display:block; }
    #viewFromEarth {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 220px;
      height: 220px;
      border: 2px solid white;
      border-radius: 10px;
      background: radial-gradient(circle at center, #000015 40%, #000000 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 20px rgba(255,255,255,0.2);
    }
    #viewFromEarth canvas {
      width: 100%;
      height: 100%;
      border-radius: 10px;
    }
    #label {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 24px;
      font-weight: bold;
      background: rgba(0, 0, 0, 0.4);
      padding: 10px;
      border-radius: 10px;
    }
    .control {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .control button {
      background: rgba(255,255,255,0.08);
      color: white;
      border: 2px solid white;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    .control button:hover { background: rgba(255,255,255,0.18); }
    .tog {
      background: rgba(255,255,255,0.04);
      border-style: dashed;
    }
    #hint {
      position: absolute;
      top: 58px;
      left: 10px;
      font-size: 13px;
      background: rgba(0,0,0,0.35);
      padding: 6px 10px;
      border-radius: 8px;
    }
    .modeSeg {
      display: flex;
      border-radius: 8px;
      overflow: hidden;
      border: 2px solid white;
    }
    .modeSeg button { margin: 0; border: none; border-right: 1px solid rgba(255,255,255,0.08); }
    .modeSeg button.active { background: rgba(255,255,255,0.18); }
  </style>
</head>
<body>
  <div id="label">Solar Eclipse Simulation</div>
  <div class="control">
    <button id="pauseButton">Pause</button>
    <div class="modeSeg">
      <button id="annularMode" class="active">Annular</button>
      <button id="totalMode">Total</button>
    </div>
    <button id="ringToggle" class="tog">Show Ring of Fire: Off</button>
    <button id="autoPauseToggle" class="tog">Auto-Pause at Ring: Off</button>
  </div>
  <div id="hint">Tip: Choose <strong>Total</strong> to simulate totality (moon covers the Sun in the inset). Choose <strong>Annular</strong> to see the ring of fire. Use <strong>Auto-Pause</strong> to stop at the annular/total moment.</div>
  <canvas id="mainCanvas"></canvas>
  <div id="viewFromEarth">
    <canvas id="earthView"></canvas>
  </div>

  <script>
    // ====== Setup & Hi-DPI scaling ======
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const earthViewCanvas = document.getElementById('earthView');
    const earthCtx = earthViewCanvas.getContext('2d');

    const pauseButton = document.getElementById('pauseButton');
    let paused = false;
    pauseButton.addEventListener('click', () => {
      paused = !paused;
      pauseButton.textContent = paused ? 'Resume' : 'Pause';
      ringAutoPaused = false;
    });

    // Mode controls: annular or totality
    const annularModeBtn = document.getElementById('annularMode');
    const totalModeBtn = document.getElementById('totalMode');
    let mode = 'annular'; // 'annular' or 'total'

    function setMode(m) {
      mode = m;
      annularModeBtn.classList.toggle('active', m === 'annular');
      totalModeBtn.classList.toggle('active', m === 'total');

      // ensure UI consistency
      if (mode === 'total') {
        showRing = false;
        ringToggle.textContent = `Show Ring of Fire: Off`;
      }
    }

    annularModeBtn.addEventListener('click', () => setMode('annular'));
    totalModeBtn.addEventListener('click', () => setMode('total'));

    // Ring controls
    const ringToggle = document.getElementById('ringToggle');
    const autoPauseToggle = document.getElementById('autoPauseToggle');
    let showRing = false;
    let autoPause = false;
    let ringAutoPaused = false; // true when auto-paused at ring so we don't repeatedly pause

    ringToggle.addEventListener('click', () => {
      // ring only meaningful for annular mode
      if (mode === 'total') return; // ignore
      showRing = !showRing;
      ringToggle.textContent = `Show Ring of Fire: ${showRing ? 'On' : 'Off'}`;
    });
    autoPauseToggle.addEventListener('click', () => {
      autoPause = !autoPause;
      autoPauseToggle.textContent = `Auto-Pause at Ring: ${autoPause ? 'On' : 'Off'}`;
      if (!autoPause) ringAutoPaused = false;
    });

    // Use devicePixelRatio for crisp drawing
    function setSize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      // main canvas
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      canvas.width = Math.round(window.innerWidth * dpr);
      canvas.height = Math.round(window.innerHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // keep drawing coordinates in CSS pixels

      // earth view canvas (fixed CSS size)
      const cssW = 220, cssH = 220;
      earthViewCanvas.style.width = cssW + 'px';
      earthViewCanvas.style.height = cssH + 'px';
      earthViewCanvas.width = Math.round(cssW * dpr);
      earthViewCanvas.height = Math.round(cssH * dpr);
      earthCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

      regenerateStars(); // regenerate star positions to match size
    }

    window.addEventListener('resize', setSize, { passive: true });

    // ====== Stars ======
    let stars = [];
    function regenerateStars() {
      const count = 200;
      stars = [];
      for (let i = 0; i < count; i++) {
        stars.push({
          x: Math.random() * window.innerWidth,
          y: Math.random() * window.innerHeight,
          r: Math.random() * 1.6 + 0.2,
          baseAlpha: Math.random() * 0.7 + 0.15,
          twinkleSpeed: Math.random() * 0.02 + 0.005,
          twinkleOffset: Math.random() * Math.PI * 2
        });
      }
    }

    // initialize sizes + stars
    setSize();

    // ====== Animation state ======
    let time = 0;
    let rafId = null;

    // ====== Main draw loop ======
    function drawScene() {
      if (!paused && !(autoPause && ringAutoPaused)) time += 0.01; // stop time if auto-paused

      // clear
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // center lines
      const centerY = window.innerHeight / 2;
      const sunX = window.innerWidth * 0.8;
      const earthX = window.innerWidth * 0.2;
      const moonOrbitRadius = (sunX - earthX) / 2;
      const earthOrbitRadius = (sunX - earthX);

      // stars
      ctx.save();
      stars.forEach((s) => {
        s.a = s.baseAlpha + Math.sin(time * (1 + s.twinkleSpeed * 10) + s.twinkleOffset) * 0.25;
        const alpha = Math.max(0.05, Math.min(1, s.a));
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
      });
      ctx.globalAlpha = 1;
      ctx.restore();

      // moon position
      // if we auto-paused at the ring, freeze moon by not updating time further
      const moonX = earthX + moonOrbitRadius * Math.cos(time);
      const moonY = centerY + 80 * Math.sin(time);

      // orbit trails (drawn lightly)
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      // moon orbit (elliptical-like)
      for (let a = 0; a < Math.PI * 2; a += 0.02) {
        const x = earthX + moonOrbitRadius * Math.cos(a);
        const y = centerY + 80 * Math.sin(a);
        if (a === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.stroke();

      // earth orbit curve
      ctx.strokeStyle = 'rgba(100,150,255,0.28)';
      ctx.lineWidth = 1.8;
      ctx.beginPath();
      for (let a = 0; a < Math.PI * 2; a += 0.02) {
        const x = sunX - earthOrbitRadius * Math.cos(a);
        const y = centerY + earthOrbitRadius * 0.08 * Math.sin(a);
        if (a === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.restore();

      // Sun (radial gradient)
      const sunRadius = 110;
      const sunGradient = ctx.createRadialGradient(sunX, centerY, 40, sunX, centerY, 220);
      sunGradient.addColorStop(0, '#fff7b0');
      sunGradient.addColorStop(0.35, '#ffd54a');
      sunGradient.addColorStop(0.7, 'rgba(255,180,60,0.35)');
      sunGradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.beginPath();
      ctx.arc(sunX, centerY, sunRadius, 0, Math.PI * 2);
      ctx.fillStyle = sunGradient;
      ctx.fill();

      // Sun core highlight (brighter center for light source effect)
      const sunHighlight = ctx.createRadialGradient(sunX - 30, centerY - 30, 0, sunX, centerY, sunRadius * 0.4);
      sunHighlight.addColorStop(0, 'rgba(255,255,255,0.8)');
      sunHighlight.addColorStop(0.4, 'rgba(255,255,255,0.2)');
      sunHighlight.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = sunHighlight;
      ctx.beginPath();
      ctx.arc(sunX, centerY, sunRadius * 0.6, 0, Math.PI * 2);
      ctx.fill();

      // decide if moon is between earth and sun (main view)
      const isBetween = (moonX > earthX && moonX < sunX);
      const alignment = Math.abs(moonY - centerY);

      // set moon apparent radius depending on mode
      const moonRadius = 30; // same for both modes now (user request)
      const centeredness = Math.abs((moonX - earthX) / (sunX - earthX) - 0.5); // 0 when perfectly between
      const centerThreshold = 0.03; // how strictly centered to consider the annular moment
      const verticalThreshold = 22; // vertical misalignment allowed

      const ringMoment = (mode === 'annular') && isBetween && alignment < verticalThreshold && centeredness < centerThreshold;
      const totalMoment = (mode === 'total') && isBetween && alignment < verticalThreshold && centeredness < centerThreshold;

      // if ring auto-pause is enabled and moment occurs, pause at that exact time
      if (autoPause && !ringAutoPaused && ((mode === 'annular' && ringMoment) || (mode === 'total' && totalMoment))) {
        paused = true; // freeze animation
        ringAutoPaused = true;
        pauseButton.textContent = 'Resume';
      }

      if (isBetween && alignment < 22) {
        drawShadowRegions(moonX, moonY, earthX, centerY, moonRadius, sunX, centerY);
      }
      // Earth
      const earthGradient = ctx.createRadialGradient(earthX, centerY, 8, earthX, centerY, 50);
      earthGradient.addColorStop(0, '#003366');
      earthGradient.addColorStop(1, '#001220');
      ctx.beginPath();
      ctx.arc(earthX, centerY, 50, 0, Math.PI * 2);
      ctx.fillStyle = earthGradient;
      ctx.fill();

      // Earth lit side (facing sun) - brighter
      const lightDir = Math.atan2(centerY - centerY, sunX - earthX); // angle to sun
      const litGradient = ctx.createRadialGradient(
        earthX + Math.cos(lightDir) * 15, 
        centerY + Math.sin(lightDir) * 15, 
        0, 
        earthX, 
        centerY, 
        50
      );
      litGradient.addColorStop(0, 'rgba(100,180,255,0.4)');
      litGradient.addColorStop(0.6, 'rgba(100,180,255,0.1)');
      litGradient.addColorStop(1, 'rgba(100,180,255,0)');
      ctx.fillStyle = litGradient;
      ctx.beginPath();
      ctx.arc(earthX, centerY, 50, 0, Math.PI * 2);
      ctx.fill();

      // Earth shadow side (away from sun) - darker gradient
      const shadowGradient = ctx.createRadialGradient(
        earthX - Math.cos(lightDir) * 20, 
        centerY - Math.sin(lightDir) * 20, 
        0, 
        earthX, 
        centerY, 
        50
      );
      shadowGradient.addColorStop(0, 'rgba(0,20,60,0.6)');
      shadowGradient.addColorStop(1, 'rgba(0,10,30,0)');
      ctx.fillStyle = shadowGradient;
      ctx.beginPath();
      ctx.arc(earthX, centerY, 50, 0, Math.PI * 2);
      ctx.fill();

      // land
      ctx.fillStyle = 'rgba(0,150,0,0.85)';
      ctx.beginPath();
      ctx.moveTo(earthX - 25, centerY - 15);
      ctx.bezierCurveTo(earthX - 10, centerY - 35, earthX + 15, centerY - 30, earthX + 5, centerY - 5);
      ctx.bezierCurveTo(earthX, centerY + 5, earthX - 20, centerY, earthX - 25, centerY - 15);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(earthX + 15, centerY + 10);
      ctx.bezierCurveTo(earthX + 30, centerY, earthX + 40, centerY + 25, earthX + 25, centerY + 35);
      ctx.bezierCurveTo(earthX + 10, centerY + 25, earthX + 5, centerY + 15, earthX + 15, centerY + 10);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(earthX - 15, centerY + 25);
      ctx.bezierCurveTo(earthX - 10, centerY + 20, earthX, centerY + 30, earthX - 5, centerY + 35);
      ctx.bezierCurveTo(earthX - 10, centerY + 35, earthX - 20, centerY + 30, earthX - 15, centerY + 25);
      ctx.closePath();
      ctx.fill();

      // glow around earth
      const glow = ctx.createRadialGradient(earthX, centerY, 50, earthX, centerY, 90);
      glow.addColorStop(0, 'rgba(255,255,255,0.12)');
      glow.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(earthX, centerY, 80, 0, Math.PI * 2);
      ctx.fill();

      // Moon
      ctx.beginPath();
      ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2);
      ctx.fillStyle = 'gray';
      ctx.fill();

      // Moon lighting: lit side (facing sun)
      const moonLightDir = Math.atan2(moonY - centerY, sunX - moonX);
      const moonLitGradient = ctx.createRadialGradient(
        moonX + Math.cos(moonLightDir) * 8,
        moonY + Math.sin(moonLightDir) * 8,
        0,
        moonX,
        moonY,
        moonRadius
      );
      moonLitGradient.addColorStop(0, 'rgba(220,220,220,0.8)');
      moonLitGradient.addColorStop(0.5, 'rgba(200,200,200,0.3)');
      moonLitGradient.addColorStop(1, 'rgba(150,150,150,0)');
      ctx.fillStyle = moonLitGradient;
      ctx.beginPath();
      ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2);
      ctx.fill();

      // Moon shadow side (away from sun)
      const moonShadowGradient = ctx.createRadialGradient(
        moonX - Math.cos(moonLightDir) * 10,
        moonY - Math.sin(moonLightDir) * 10,
        0,
        moonX,
        moonY,
        moonRadius
      );
      moonShadowGradient.addColorStop(0, 'rgba(20,20,30,0.8)');
      moonShadowGradient.addColorStop(1, 'rgba(20,20,30,0)');
      ctx.fillStyle = moonShadowGradient;
      ctx.beginPath();
      ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2);
      ctx.fill();

      // inset earth view
      drawEarthView(moonX, moonY, earthX, centerY, sunX, sunRadius, moonRadius, ringMoment || totalMoment);

      rafId = requestAnimationFrame(drawScene);
    }

    // ====== Shadow rendering (umbra + penumbra) ======
    function drawShadowRegions(mx, my, ex, ey, moonRadius, sunX, centerY) {
      // Shadow direction: away from Sun (light source)
      const sunToMoonX = mx - sunX;
      const sunToMoonY = my - centerY;
      const dist = Math.hypot(sunToMoonX, sunToMoonY) || 1;
      const ux = sunToMoonX / dist;  // unit vector pointing away from sun
      const uy = sunToMoonY / dist;
      // perpendicular to shadow direction
      const px = -uy;
      const py = ux;

      // spreads control shape width at moon (increased for visibility)
      const umbraSpread = 60;
      const penumbraSpread = 160;
      
      // PENUMBRA RAYS: parallel rays (NOT crisscrossing) - both on same side
      // Left penumbra ray: Sun LEFT edge → Moon LEFT edge (parallel)
      const penLeftSunX = sunX - px * penumbraSpread * 0.5;  // LEFT side of sun
      const penLeftSunY = centerY - py * penumbraSpread * 0.5;
      const penLeftMoonX = mx - px * penumbraSpread * 0.5;   // LEFT side of moon
      const penLeftMoonY = my - py * penumbraSpread * 0.5;
      const penLeftEndX = ex - px * penumbraSpread * 0.3;
      const penLeftEndY = ey - py * penumbraSpread * 0.3;
      
      // Right penumbra ray: Sun RIGHT edge → Moon RIGHT edge (parallel, same side)
      const penRightSunX = sunX + px * penumbraSpread * 0.5;  // RIGHT side of sun
      const penRightSunY = centerY + py * penumbraSpread * 0.5;
      const penRightMoonX = mx + px * penumbraSpread * 0.5;   // RIGHT side of moon
      const penRightMoonY = my + py * penumbraSpread * 0.5;
      const penRightEndX = ex + px * penumbraSpread * 0.3;
      const penRightEndY = ey + py * penumbraSpread * 0.3;
      
      // UMBRA RAYS: crisscrossing from opposite Sun edges to opposite Moon edges (narrower)
      // Left umbra ray: Sun RIGHT edge → Moon LEFT edge
      const umbLeftSunX = sunX + px * umbraSpread * 0.5;      // RIGHT side of sun
      const umbLeftSunY = centerY + py * umbraSpread * 0.5;
      const umbLeftMoonX = mx - px * umbraSpread * 0.5;       // LEFT side of moon
      const umbLeftMoonY = my - py * umbraSpread * 0.5;
      const umbLeftEndX = ex - px * umbraSpread * 0.25;
      const umbLeftEndY = ey - py * umbraSpread * 0.25;
      
      // Right umbra ray: Sun LEFT edge → Moon RIGHT edge (crisscross)
      const umbRightSunX = sunX - px * umbraSpread * 0.5;     // LEFT side of sun
      const umbRightSunY = centerY - py * umbraSpread * 0.5;
      const umbRightMoonX = mx + px * umbraSpread * 0.5;      // RIGHT side of moon
      const umbRightMoonY = my + py * umbraSpread * 0.5;
      const umbRightEndX = ex + px * umbraSpread * 0.25;
      const umbRightEndY = ey + py * umbraSpread * 0.25;

      ctx.save();

      // Draw penumbra cone as filled region
      const penLeftStartX = mx - px * penumbraSpread * 0.5;
      const penLeftStartY = my - py * penumbraSpread * 0.5;
      const penRightStartX = mx + px * penumbraSpread * 0.5;
      const penRightStartY = my + py * penumbraSpread * 0.5;

      // gradient across the penumbra width - more visible
      const gradient = ctx.createLinearGradient(penLeftStartX, penLeftStartY, penRightStartX, penRightStartY);
      gradient.addColorStop(0, 'rgba(0,0,0,0.0)');
      gradient.addColorStop(0.5, 'rgba(0,0,0,0.35)');
      gradient.addColorStop(1, 'rgba(0,0,0,0.0)');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.moveTo(penLeftStartX, penLeftStartY);
      ctx.lineTo(penRightStartX, penRightStartY);
      ctx.lineTo(penRightEndX, penRightEndY);
      ctx.lineTo(penLeftEndX, penLeftEndY);
      ctx.closePath();
      ctx.fill();

      // Draw umbra cone as filled region
      const umbLeftStartX = mx - px * umbraSpread * 0.5;
      const umbLeftStartY = my - py * umbraSpread * 0.5;
      const umbRightStartX = mx + px * umbraSpread * 0.5;
      const umbRightStartY = my + py * umbraSpread * 0.5;

      // darker center with gradient for visibility
      const umbraGradient = ctx.createLinearGradient(umbLeftStartX, umbLeftStartY, umbRightStartX, umbRightStartY);
      umbraGradient.addColorStop(0, 'rgba(0,0,0,0.2)');
      umbraGradient.addColorStop(0.5, 'rgba(0,0,0,0.75)');
      umbraGradient.addColorStop(1, 'rgba(0,0,0,0.2)');
      
      ctx.fillStyle = umbraGradient;
      ctx.beginPath();
      ctx.moveTo(umbLeftStartX, umbLeftStartY);
      ctx.lineTo(umbRightStartX, umbRightStartY);
      ctx.lineTo(umbRightEndX, umbRightEndY);
      ctx.lineTo(umbLeftEndX, umbLeftEndY);
      ctx.closePath();
      ctx.fill();

      // Draw HIDDEN penumbra rays (Sun to Moon) - very faint dashed
      ctx.strokeStyle = 'rgba(200,200,200,0.15)';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]); // dashed line for hidden rays
      
      // Left penumbra hidden ray (sun to moon)
      ctx.beginPath();
      ctx.moveTo(penLeftSunX, penLeftSunY);
      ctx.lineTo(penLeftMoonX, penLeftMoonY);
      ctx.stroke();
      
      // Right penumbra hidden ray (sun to moon)
      ctx.beginPath();
      ctx.moveTo(penRightSunX, penRightSunY);
      ctx.lineTo(penRightMoonX, penRightMoonY);
      ctx.stroke();
      
      // Draw VISIBLE penumbra rays (Moon to Earth) - grey dashed
      ctx.strokeStyle = 'rgba(200,200,200,0.5)';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      
      // Left penumbra visible ray (moon to earth)
      ctx.beginPath();
      ctx.moveTo(penLeftMoonX, penLeftMoonY);
      ctx.lineTo(penLeftEndX, penLeftEndY);
      ctx.stroke();
      
      // Right penumbra visible ray (moon to earth)
      ctx.beginPath();
      ctx.moveTo(penRightMoonX, penRightMoonY);
      ctx.lineTo(penRightEndX, penRightEndY);
      ctx.stroke();
      
      // Draw HIDDEN umbra rays (Sun to Moon) - very faint dashed
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 2.5;
      ctx.setLineDash([5, 5]); // dashed line for hidden rays
      
      // Left umbra hidden ray (sun to moon)
      ctx.beginPath();
      ctx.moveTo(umbLeftSunX, umbLeftSunY);
      ctx.lineTo(umbLeftMoonX, umbLeftMoonY);
      ctx.stroke();
      
      // Right umbra hidden ray (sun to moon)
      ctx.beginPath();
      ctx.moveTo(umbRightSunX, umbRightSunY);
      ctx.lineTo(umbRightMoonX, umbRightMoonY);
      ctx.stroke();
      
      // Draw VISIBLE umbra rays (Moon to Earth) - white solid
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = 2.5;
      ctx.setLineDash([]); // solid line for visible rays
      
      // Left umbra visible ray (moon to earth)
      ctx.beginPath();
      ctx.moveTo(umbLeftMoonX, umbLeftMoonY);
      ctx.lineTo(umbLeftEndX, umbLeftEndY);
      ctx.stroke();
      
      // Right umbra visible ray (moon to earth)
      ctx.beginPath();
      ctx.moveTo(umbRightMoonX, umbRightMoonY);
      ctx.lineTo(umbRightEndX, umbRightEndY);
      ctx.stroke();
      
      ctx.setLineDash([]); // reset line dash

      ctx.restore();
    }

    // ====== Earth inset view (what an observer sees) ======
    function drawEarthView(moonX, moonY, earthX, centerY, sunX, sunRadius, moonRadius, ringMoment) {
      // css coordinates within earthViewCanvas: 0..220
      earthCtx.clearRect(0, 0, 220, 220);
      earthCtx.save();

      // center at (110,110) and rotate for stylized view
      earthCtx.translate(110, 110);
      earthCtx.rotate(-Math.PI / 2);
      earthCtx.translate(-110, -110);

      // sun disc in inset
      const sunInsetRadius = 65;
      const sunGrad = earthCtx.createRadialGradient(110, 110, 30, 110, 110, 70);
      sunGrad.addColorStop(0, '#ffffcc');
      sunGrad.addColorStop(1, '#ffaa00');
      earthCtx.beginPath();
      earthCtx.arc(110, 110, sunInsetRadius, 0, Math.PI * 2);
      earthCtx.fillStyle = sunGrad;
      earthCtx.fill();

      const isBetween = (moonX < sunX && moonX > earthX);
      const alignment = Math.abs(moonY - centerY);

      if (isBetween && alignment < 110) {
        // map moon position proportionally into inset (approx)
        const relX = ((moonX - earthX) / (sunX - earthX)) * 220 - 110;
        const relY = ((moonY - centerY) / (window.innerHeight * 0.35)) * 220; // scaled

        // default inset moon radius and adjustments per mode
        let moonInsetRadius = (mode === 'total') ? sunInsetRadius + 6 : 60; // total: slightly larger so it fully covers
        const ringThickness = 6; // how thin the visible sun ring is when annular

        let moonInsetX = 110 + relX;
        let moonInsetY = 110 + relY;

        // when showing ring and we are in the annular/centered moment, shrink moon to just reveal a thin ring
        if (mode === 'annular' && showRing && ringMoment) {
          moonInsetRadius = Math.max(4, sunInsetRadius - ringThickness);
          // snap to center for symmetrical ring
          moonInsetX = 110; moonInsetY = 110;
        }

        // for total mode snap to center at total moment for symmetry
        if (mode === 'total' && ringMoment) {
          moonInsetRadius = sunInsetRadius + 6;
          moonInsetX = 110; moonInsetY = 110;
        }

        // draw moon silhouette (bigger by default)
        earthCtx.beginPath();
        earthCtx.arc(moonInsetX, moonInsetY, moonInsetRadius, 0, Math.PI * 2);
        // use fully opaque black to prevent any light bleed-through
        earthCtx.globalCompositeOperation = 'source-over'; // reset to normal blend
        earthCtx.fillStyle = 'rgba(0,0,0,1.0)';
        earthCtx.fill();

        // annular ring drawing
        if (mode === 'annular' && showRing && ringMoment) {
          const glowOuter = moonInsetRadius + 8;
          const glow = earthCtx.createRadialGradient(moonInsetX, moonInsetY, moonInsetRadius + 2, moonInsetX, moonInsetY, glowOuter);
          glow.addColorStop(0, 'rgba(255,240,180,0.95)');
          glow.addColorStop(0.15, 'rgba(255,200,80,0.65)');
          glow.addColorStop(0.35, 'rgba(255,160,40,0.25)');
          glow.addColorStop(1, 'rgba(255,160,40,0)');
          earthCtx.globalCompositeOperation = 'lighter';
          earthCtx.fillStyle = glow;
          earthCtx.beginPath();
          earthCtx.arc(moonInsetX, moonInsetY, glowOuter, 0, Math.PI * 2);
          earthCtx.fill();
          earthCtx.globalCompositeOperation = 'source-over';

          // redraw moon on top to ensure it stays opaque
          earthCtx.beginPath();
          earthCtx.arc(moonInsetX, moonInsetY, moonInsetRadius, 0, Math.PI * 2);
          earthCtx.fillStyle = 'rgba(0,0,0,1.0)';
          earthCtx.fill();

          // subtle bright stroke to emphasize the thin ring
          earthCtx.beginPath();
          earthCtx.lineWidth = 2;
          earthCtx.strokeStyle = 'rgba(255,230,160,0.95)';
          earthCtx.arc(moonInsetX, moonInsetY, moonInsetRadius + (ringThickness/2), 0, Math.PI * 2);
          earthCtx.stroke();
        } else if (mode === 'total' && ringMoment) {
          // totality corona: small bright corona glow when total and atMoment
          const corona = earthCtx.createRadialGradient(110, 110, moonInsetRadius, 110, 110, 100);
          corona.addColorStop(0, 'rgba(255,255,255,0.18)');
          corona.addColorStop(1, 'rgba(255,255,255,0)');
          earthCtx.fillStyle = corona;
          earthCtx.fillRect(0, 0, 220, 220);

          // redraw moon on top to ensure it stays opaque after corona
          earthCtx.beginPath();
          earthCtx.arc(moonInsetX, moonInsetY, moonInsetRadius, 0, Math.PI * 2);
          earthCtx.fillStyle = 'rgba(0,0,0,1.0)';
          earthCtx.fill();

          // draw a subtle bright thin outer halo representing solar corona peeking beyond lunar limb
          earthCtx.beginPath();
          earthCtx.lineWidth = 3;
          earthCtx.strokeStyle = 'rgba(255,240,220,0.9)';
          earthCtx.arc(110, 110, moonInsetRadius + 4, 0, Math.PI * 2);
          earthCtx.stroke();

          // Diamond ring: bright sparkling point on the lunar limb
          const diamondRadius = 5;
          const diamondX = 110 + moonInsetRadius + 4; // on the right limb
          const diamondY = 110;

          // bright core
          const dGrad = earthCtx.createRadialGradient(diamondX, diamondY, 0, diamondX, diamondY, diamondRadius * 3);
          dGrad.addColorStop(0, 'rgba(255,255,255,1)');
          dGrad.addColorStop(0.15, 'rgba(255,245,220,0.95)');
          dGrad.addColorStop(0.4, 'rgba(255,200,120,0.5)');
          dGrad.addColorStop(1, 'rgba(255,160,40,0)');
          earthCtx.globalCompositeOperation = 'lighter';
          earthCtx.fillStyle = dGrad;
          earthCtx.beginPath();
          earthCtx.arc(diamondX, diamondY, diamondRadius * 3, 0, Math.PI * 2);
          earthCtx.fill();

          // small core
          earthCtx.beginPath();
          earthCtx.fillStyle = 'rgba(255,255,255,0.98)';
          earthCtx.arc(diamondX, diamondY, diamondRadius, 0, Math.PI * 2);
          earthCtx.fill();

          // sparkle cross
          earthCtx.lineWidth = 2;
          earthCtx.strokeStyle = 'rgba(255,255,255,0.95)';
          earthCtx.beginPath();
          earthCtx.moveTo(diamondX - 12, diamondY);
          earthCtx.lineTo(diamondX + 12, diamondY);
          earthCtx.moveTo(diamondX, diamondY - 12);
          earthCtx.lineTo(diamondX, diamondY + 12);
          earthCtx.stroke();

          // diagonal glints
          earthCtx.lineWidth = 1.2;
          earthCtx.beginPath();
          earthCtx.moveTo(diamondX - 9, diamondY - 9);
          earthCtx.lineTo(diamondX + 9, diamondY + 9);
          earthCtx.moveTo(diamondX - 9, diamondY + 9);
          earthCtx.lineTo(diamondX + 9, diamondY - 9);
          earthCtx.stroke();

          earthCtx.globalCompositeOperation = 'source-over';
        } else {
          // non-annular small corona effect when near center
          const overlap = Math.max(0, 1 - Math.abs(relX) / 110);
          const darkness = Math.min(0.92, overlap * 0.92);
          if (Math.abs(relX) < 12 && alignment < 50) {
            const corona = earthCtx.createRadialGradient(110, 110, 60, 110, 110, 95);
            corona.addColorStop(0, 'rgba(255,255,255,0.14)');
            corona.addColorStop(1, 'rgba(255,255,255,0)');
            earthCtx.fillStyle = corona;
            earthCtx.fillRect(0, 0, 220, 220);

            // redraw moon on top to ensure it stays opaque
            earthCtx.beginPath();
            earthCtx.arc(moonInsetX, moonInsetY, moonInsetRadius, 0, Math.PI * 2);
            earthCtx.fillStyle = 'rgba(0,0,0,1.0)';
            earthCtx.fill();
          }
        }
      }

      earthCtx.restore();
    }

    // start
    drawScene();

  </script>
</body>
</html>
