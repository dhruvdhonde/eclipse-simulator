<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Advanced Eclipse Lab — Solar & Lunar (Single File)</title>
<style>
:root{
  --bg:#ffffff; --card:#fffdf4; --accent:#f6b100; --muted:#6b6b6b; --glass:rgba(0,0,0,0.04);
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:#222}
.container{max-width:1280px;margin:18px auto;padding:14px}
.header{display:flex;align-items:center;justify-content:space-between;gap:12px}
.title{display:flex;flex-direction:column}
h1{margin:0;color:var(--accent);font-size:1.6rem;letter-spacing:0.6px}
.subtitle{color:var(--muted);font-size:0.92rem;margin-top:6px}
.layout{display:grid;grid-template-columns:420px 1fr;gap:14px;margin-top:12px}
.card{background:var(--card);padding:12px;border-radius:12px;border:1px solid rgba(0,0,0,0.03);box-shadow:0 6px 20px rgba(0,0,0,0.04)}
.controls{display:flex;flex-direction:column;gap:8px}
.row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.label{font-size:0.85rem;color:var(--muted);min-width:120px}
.small{font-size:0.85rem;color:var(--muted)}
input[type=range]{width:160px}
select, input[type=number], input[type=text]{padding:6px 8px;border-radius:8px;border:1px solid rgba(0,0,0,0.06)}
.button{background:linear-gradient(180deg,var(--accent),#e6a800);border:none;padding:8px 12px;border-radius:8px;color:white;cursor:pointer;font-weight:600}
.button.secondary{background:#ffffff;border:1px solid #eee;color:#333}
.button.ghost{background:transparent;border:1px dashed #eee;color:#333}
.canvas-wrap{display:flex;flex-direction:column;gap:10px}
#skyCanvas{width:100%;height:560px;border-radius:10px;background:linear-gradient(180deg,#fff,#fffdf8);border:1px solid #f3e8c0}
.bottom-row{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-top:8px}
.legend{font-size:0.85rem;color:var(--muted)}
.controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.kv{display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-radius:8px;background:transparent;font-size:0.9rem}
.info{font-size:0.9rem;color:#333}
.footer{margin-top:12px;font-size:0.85rem;color:var(--muted)}
.canvas-row{display:flex;gap:12px}
.plot{width:100%;height:160px;border-radius:8px;background:#fff;border:1px solid #f0e7d0}
.badge{display:inline-block;padding:6px 8px;border-radius:8px;background:#fff8e1;color:#7a4d00;border:1px solid #f1e0a4;font-weight:600}
.toggle{display:inline-flex;align-items:center;gap:8px}
.checkbox{transform:scale(1.05);margin-right:6px}
@media(max-width:1100px){.layout{grid-template-columns:1fr;}}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="title">
      <h1>Advanced Eclipse Lab</h1>
      <div class="subtitle">Solar & Lunar — umbra/penumbra, ring/diamond effects, path-of-totality (single-file)</div>
    </div>
    <div style="text-align:right">
      <div class="badge">White / Yellow Minimal Theme</div>
      <div style="height:6px"></div>
      <div class="small">Author: Dhruv • Submission-ready</div>
    </div>
  </div>

  <div class="layout">
    <div class="card controls">
      <div style="font-weight:700;margin-bottom:6px">Controls</div>

      <div class="row">
        <div class="label">Mode</div>
        <select id="modeSelect">
          <option value="solar">Solar Eclipse</option>
          <option value="lunar">Lunar Eclipse</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Run</div>
        <button id="startBtn" class="button">Start</button>
        <button id="pauseBtn" class="button secondary">Pause</button>
        <button id="stepBtn" class="button ghost">Step</button>
        <button id="resetBtn" class="button secondary">Reset</button>
      </div>

      <div class="row">
        <div class="label">Speed</div>
        <input id="speedRange" type="range" min="0.1" max="6" step="0.1" value="1">
        <div class="kv"><span class="small">x</span><span id="speedVal">1.0</span></div>
      </div>

      <div class="row">
        <div class="label">Impact (path offset)</div>
        <input id="impactRange" type="range" min="-1" max="1" step="0.01" value="0">
        <div class="kv"><span class="small">offset</span><span id="impactVal">0.00</span></div>
      </div>

      <div class="row">
        <div class="label">Moon distance scale</div>
        <input id="moonDistRange" type="range" min="0.8" max="1.3" step="0.01" value="1">
        <div class="kv"><span class="small">scale</span><span id="moonDistVal">1.00</span></div>
      </div>

      <div class="row">
        <div class="label">Sun radius scale</div>
        <input id="sunScaleRange" type="range" min="0.6" max="1.4" step="0.01" value="1">
        <div class="kv"><span class="small">scale</span><span id="sunScaleVal">1.00</span></div>
      </div>

      <div class="row">
        <div class="label">Moon radius scale</div>
        <input id="moonScaleRange" type="range" min="0.6" max="1.4" step="0.01" value="1">
        <div class="kv"><span class="small">scale</span><span id="moonScaleVal">1.00</span></div>
      </div>

      <div class="row">
        <div class="label">Sampling</div>
        <input id="samplesRange" type="range" min="40" max="400" step="10" value="140">
        <div class="kv"><span class="small">samples</span><span id="samplesVal">140</span></div>
      </div>

      <div class="row">
        <div class="label">Graphics</div>
        <label class="toggle"><input id="limbToggle" class="checkbox" type="checkbox" checked> Limb darkening</label>
        <label class="toggle"><input id="guidesToggle" class="checkbox"> Show guides</label>
      </div>

      <div class="row">
        <div class="label">Phenomena</div>
        <label class="toggle"><input id="diamondToggle" class="checkbox" type="checkbox" checked> Diamond ring</label>
        <label class="toggle"><input id="ringToggle" class="checkbox" type="checkbox" checked> Ring of fire</label>
      </div>

      <div class="row">
        <div class="label">Export</div>
        <button id="exportPNG" class="button">Export PNG</button>
        <button id="exportCSV" class="button secondary">Export CSV</button>
      </div>

      <div style="height:8px"></div>
      <div class="small">Presets</div>
      <div class="row" style="gap:6px">
        <button class="button secondary presetBtn" data-preset="total">Total Eclipse</button>
        <button class="button secondary presetBtn" data-preset="annular">Annular (Ring)</button>
        <button class="button secondary presetBtn" data-preset="lunar">Lunar Total</button>
      </div>

      <div style="height:10px"></div>
      <div class="small">Status</div>
      <div class="kv" id="statusBox">Idle</div>

    </div>

    <div class="card canvas-wrap">
      <div class="canvas-row">
        <canvas id="skyCanvas" width="820" height="560"></canvas>
      </div>

      <div class="canvas-row" style="margin-top:6px">
        <canvas id="fluxCanvas" width="400" height="160" class="plot"></canvas>
        <canvas id="fractionsCanvas" width="400" height="160" class="plot"></canvas>
      </div>

      <div class="bottom-row">
        <div class="legend">Left: Sky-plane. Right: Light curve (flux) and Umbra/Penumbra fractions.</div>
        <div class="small">Tip: Use presets for quick realistic scenarios</div>
      </div>

    </div>
  </div>

  <div class="footer small card">
    Includes: apparent angular radii (α = arctan(R/d)), circle–circle intersection for obscuration, umbra/penumbra via similar-triangles, limb darkening sampling, ring/diamond-ring visual effects, CSV/PNG export, multiple user controls.
  </div>

</div>

<script>
(function(){
  // -- Canvas contexts
  const skyC = document.getElementById('skyCanvas'), sky = skyC.getContext('2d');
  const fluxC = document.getElementById('fluxCanvas'), fluxCtx = fluxC.getContext('2d');
  const fracC = document.getElementById('fractionsCanvas'), fracCtx = fracC.getContext('2d');

  // -- Controls
  const modeSelect = document.getElementById('modeSelect');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stepBtn = document.getElementById('stepBtn');
  const resetBtn = document.getElementById('resetBtn');
  const speedRange = document.getElementById('speedRange');
  const impactRange = document.getElementById('impactRange');
  const moonDistRange = document.getElementById('moonDistRange');
  const sunScaleRange = document.getElementById('sunScaleRange');
  const moonScaleRange = document.getElementById('moonScaleRange');
  const samplesRange = document.getElementById('samplesRange');
  const limbToggle = document.getElementById('limbToggle');
  const guidesToggle = document.getElementById('guidesToggle');
  const diamondToggle = document.getElementById('diamondToggle');
  const ringToggle = document.getElementById('ringToggle');
  const exportPNG = document.getElementById('exportPNG');
  const exportCSV = document.getElementById('exportCSV');
  const presetBtns = document.querySelectorAll('.presetBtn');
  const statusBox = document.getElementById('statusBox');

  // -- display spans
  const speedVal = document.getElementById('speedVal');
  const impactVal = document.getElementById('impactVal');
  const moonDistVal = document.getElementById('moonDistVal');
  const sunScaleVal = document.getElementById('sunScaleVal');
  const moonScaleVal = document.getElementById('moonScaleVal');
  const samplesVal = document.getElementById('samplesVal');

  // -- simulation state
  const STATE = {
    mode: 'solar',
    running: false,
    t: 0,          // normalized 0..1
    dt: 0.002,
    speed: parseFloat(speedRange.value),
    impact: parseFloat(impactRange.value),
    moonDistScale: parseFloat(moonDistRange.value),
    sunScale: parseFloat(sunScaleRange.value),
    moonScale: parseFloat(moonScaleRange.value),
    samples: parseInt(samplesRange.value,10),
    limb: limbToggle.checked,
    guides: guidesToggle.checked,
    showDiamond: diamondToggle.checked,
    showRing: ringToggle.checked,
    fluxSeries: [],
    umbraSeries: []
  };

  // physical constants (km)
  const PHY = {
    R_sun: 695700,
    R_earth: 6371,
    R_moon: 1737.4,
    d_earth_sun: 149600000,
    d_earth_moon: 384400
  };

  // canvas sizing helper
  function fitCanvases(){
    [skyC, fluxC, fracC].forEach(c=>{
      const ratio = Math.min(window.devicePixelRatio || 1, 2);
      const w = c.clientWidth, h = c.clientHeight;
      c.width = Math.floor(w * ratio);
      c.height = Math.floor(h * ratio);
      const ctx = c.getContext('2d');
      ctx.setTransform(ratio,0,0,ratio,0,0);
    });
  }
  window.addEventListener('resize', fitCanvases);
  fitCanvases();

  // ---------------- math helpers ----------------
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function angularRadius(R_km, d_km){ return Math.atan2(R_km, d_km); }

  function circleOverlapArea(r1, r2, d){
    if (d >= r1 + r2) return 0;
    if (d <= Math.abs(r1 - r2)) return Math.PI * Math.min(r1,r2)**2;
    const r1sq = r1*r1, r2sq = r2*r2;
    const alpha = Math.acos(clamp((d*d + r1sq - r2sq) / (2 * d * r1), -1,1));
    const beta  = Math.acos(clamp((d*d + r2sq - r1sq) / (2 * d * r2), -1,1));
    const area = r1sq*alpha + r2sq*beta - 0.5 * Math.sqrt(
      Math.max(0, (-d + r1 + r2) * (d + r1 - r2) * (d - r1 + r2) * (d + r1 + r2))
    );
    return area;
  }

  function limbFactor(rFrac, u=0.6){
    if (rFrac >= 1) return 0;
    return 1 - u * (1 - Math.sqrt(Math.max(0, 1 - rFrac*rFrac)));
  }

  function umbraPenumbraRadiiAtMoonDistance(moonDistance_km){
    const R_e = PHY.R_earth, R_s = PHY.R_sun, D_es = PHY.d_earth_sun;
    const L_umbra = (R_e * D_es) / Math.max(1e-9, (R_s - R_e));
    const r_umbra = Math.max(0, R_e * (1 - moonDistance_km / L_umbra));
    const sun_ang = Math.atan2(R_s, D_es);
    const pen_extra = Math.tan(sun_ang) * moonDistance_km;
    const r_penumbra = r_umbra + pen_extra * 1.02;
    return {r_umbra, r_penumbra, L_umbra};
  }

  // limb-darkened flux sampler
  function computeLimbDarkenedFlux(sunR_canvas, moonX, moonY, moonR_canvas, samples){
    const R = sunR_canvas;
    const n = Math.max(20, Math.min(420, samples));
    const step = (2*R)/n;
    let total = 0, visible = 0;
    for (let i=0;i<n;i++){
      const x = -R + (i+0.5)*step;
      for (let j=0;j<n;j++){
        const y = -R + (j+0.5)*step;
        const r = Math.hypot(x,y);
        if (r <= R){
          const lf = limbFactor(r/R, 0.6);
          total += lf;
          const rx = x - moonX;
          const ry = y - moonY;
          if (Math.hypot(rx,ry) > moonR_canvas) visible += lf;
        }
      }
    }
    return total <= 0 ? 1.0 : visible / total;
  }

  // ---------------- UI bindings ----------------
  function updateDisplayValues(){
    speedVal.textContent = STATE.speed.toFixed(2);
    impactVal.textContent = STATE.impact.toFixed(2);
    moonDistVal.textContent = STATE.moonDistScale.toFixed(2);
    sunScaleVal.textContent = STATE.sunScale.toFixed(2);
    moonScaleVal.textContent = STATE.moonScale.toFixed(2);
    samplesVal.textContent = STATE.samples;
  }

  speedRange.addEventListener('input', ()=>{
    STATE.speed = parseFloat(speedRange.value);
    updateDisplayValues();
  });
  impactRange.addEventListener('input', ()=>{
    STATE.impact = parseFloat(impactRange.value);
    updateDisplayValues();
  });
  moonDistRange.addEventListener('input', ()=>{
    STATE.moonDistScale = parseFloat(moonDistRange.value);
    updateDisplayValues();
  });
  sunScaleRange.addEventListener('input', ()=>{
    STATE.sunScale = parseFloat(sunScaleRange.value);
    updateDisplayValues();
  });
  moonScaleRange.addEventListener('input', ()=>{
    STATE.moonScale = parseFloat(moonScaleRange.value);
    updateDisplayValues();
  });
  samplesRange.addEventListener('input', ()=>{
    STATE.samples = parseInt(samplesRange.value,10);
    updateDisplayValues();
  });
  limbToggle.addEventListener('change', ()=> STATE.limb = limbToggle.checked);
  guidesToggle.addEventListener('change', ()=> STATE.guides = guidesToggle.checked);
  diamondToggle.addEventListener('change', ()=> STATE.showDiamond = diamondToggle.checked);
  ringToggle.addEventListener('change', ()=> STATE.showRing = ringToggle.checked);

  modeSelect.addEventListener('change', ()=>{
    STATE.mode = modeSelect.value;
    resetRun();
  });

  startBtn.addEventListener('click', ()=>{ STATE.running = true; setStatus('Running'); });
  pauseBtn.addEventListener('click', ()=>{ STATE.running = false; setStatus('Paused'); });
  stepBtn.addEventListener('click', ()=>{ stepOnce(); });
  resetBtn.addEventListener('click', ()=>{ resetRun(); setStatus('Reset'); });

  presetBtns.forEach(btn=>{
    btn.addEventListener('click', ()=> applyPreset(btn.dataset.preset));
  });

  exportPNG.addEventListener('click', exportSkyPNG);
  exportCSV.addEventListener('click', exportCSV);

  function setStatus(s){ statusBox.textContent = s; }

  // presets
  function applyPreset(name){
    if (name === 'total'){
      modeSelect.value='solar'; STATE.mode='solar';
      moonDistRange.value=1.03; STATE.moonDistScale=1.03;
      moonScaleRange.value=1.00; STATE.moonScale=1.00;
      sunScaleRange.value=1.00; STATE.sunScale=1.00;
      impactRange.value=0; STATE.impact=0;
      samplesRange.value=200; STATE.samples=200;
      limbToggle.checked=true; STATE.limb=true;
    } else if (name === 'annular'){
      modeSelect.value='solar'; STATE.mode='solar';
      moonDistRange.value=1.30; STATE.moonDistScale=1.30;
      moonScaleRange.value=0.9; STATE.moonScale=0.9;
      sunScaleRange.value=1.05; STATE.sunScale=1.05;
      impactRange.value=0; STATE.impact=0;
      samplesRange.value=120; STATE.samples=120;
    } else if (name === 'lunar'){
      modeSelect.value='lunar'; STATE.mode='lunar';
      moonDistRange.value=1.00; STATE.moonDistScale=1.00;
      moonScaleRange.value=1.00; STATE.moonScale=1.00;
      sunScaleRange.value=1.00; STATE.sunScale=1.00;
      impactRange.value=0; STATE.impact=0;
      samplesRange.value=140; STATE.samples=140;
    }
    updateDisplayValues();
    resetRun();
    setStatus('Preset applied: '+name);
  }

  // reset, step
  function resetRun(){
    STATE.running = false;
    STATE.t = 0;
    STATE.fluxSeries.length = 0;
    STATE.umbraSeries.length = 0;
    setStatus('Ready');
    drawFrame(0);
  }

  function stepOnce(){
    STATE.t += STATE.dt * STATE.speed;
    if (STATE.t > 1) STATE.t = 1;
    computeStepAndDraw();
    setStatus('Stepped to '+ (STATE.t*100).toFixed(2) + '%');
  }

  // compute canvas radii mapping
  function computeCanvasRadii(){
    const sunAng = angularRadius(PHY.R_sun * STATE.sunScale, PHY.d_earth_sun);
    const moonAng = angularRadius(PHY.R_moon * STATE.moonScale, PHY.d_earth_moon * STATE.moonDistScale);
    const canvasMin = Math.min(skyC.clientWidth, skyC.clientHeight);
    const desiredPixels = canvasMin * 0.35;
    const scale = desiredPixels / sunAng;
    const rSun = sunAng * scale;
    const rMoon = moonAng * scale;
    return {scale, rSun, rMoon, sunAng, moonAng};
  }

  // compute model state for normalized u in [0,1]
  function computeState(u){
    const {scale, rSun, rMoon} = computeCanvasRadii();
    const travel = 2.3 * (rSun + rMoon);
    const x = -travel/2 + travel * u;
    const y = STATE.impact * (rSun + rMoon);
    const d = Math.hypot(x,y);
    const A_overlap = circleOverlapArea(rSun, rMoon, d);
    const obscuration = A_overlap / (Math.PI * rSun * rSun);
    let flux = 1 - obscuration;
    if (STATE.limb){
      // moon center relative to sun centre for sampling
      flux = computeLimbDarkenedFlux(rSun, x, y, rMoon, STATE.samples);
    }
    // umbra/penumbra at moon physical distance
    const moonPhysicalDistance = PHY.d_earth_moon * STATE.moonDistScale;
    const umbPen = umbraPenumbraRadiiAtMoonDistance(moonPhysicalDistance);
    const km2canvas = rMoon / PHY.R_moon;
    const cuUmbra = umbPen.r_umbra * km2canvas;
    const cuPenumbra = umbPen.r_penumbra * km2canvas;
    const dCenter = Math.hypot(x,y);
    const Au = circleOverlapArea(rMoon, cuUmbra, dCenter);
    const Ap = circleOverlapArea(rMoon, cuPenumbra, dCenter);
    const penOnly = Math.max(0, Ap - Au);
    const umbra_frac = Au / (Math.PI * rMoon * rMoon);
    const pen_frac = penOnly / (Math.PI * rMoon * rMoon);
    return {x,y,rSun,rMoon,obscuration,flux,A_overlap,cuUmbra,cuPenumbra,umbra_frac,pen_frac};
  }

  // draw helpers
  function clearSky(){
    sky.clearRect(0,0,skyC.clientWidth,skyC.clientHeight);
    sky.fillStyle = "#fff";
    sky.fillRect(0,0,skyC.clientWidth,skyC.clientHeight);
  }

  function drawSun(cx,cy,r){
    const rings = 36;
    for (let i=rings;i>0;i--){
      const rf = i / rings;
      const br = limbFactor(rf, 0.6);
      const cr = Math.floor(255 * (0.95*br + 0.05));
      const cg = Math.floor(220 * (0.9*br + 0.1));
      const cb = Math.floor(80 * (0.9*br + 0.1));
      sky.beginPath();
      sky.fillStyle = `rgb(${cr},${cg},${cb})`;
      sky.arc(cx, cy, r * rf, 0, Math.PI*2);
      sky.fill();
    }
  }

  function drawMoon(cx,cy,r,fill='#333'){
    sky.beginPath();
    sky.fillStyle = fill;
    sky.arc(cx, cy, r, 0, Math.PI*2);
    sky.fill();
  }

  function drawGuides(cx,cy,rSun,rMoon,x,y,cuUmbra,cuPenumbra){
    sky.save();
    sky.translate(cx,cy);
    sky.strokeStyle = 'rgba(0,0,0,0.08)';
    sky.lineWidth = 1;
    sky.beginPath(); sky.arc(0,0,rSun,0,Math.PI*2); sky.stroke();
    sky.beginPath(); sky.arc(0,0,cuPenumbra,0,Math.PI*2); sky.stroke();
    sky.beginPath(); sky.arc(0,0,cuUmbra,0,Math.PI*2); sky.stroke();
    sky.beginPath(); sky.arc(x,y,rMoon,0,Math.PI*2); sky.stroke();
    sky.restore();
  }

  function drawDiamondRingIfNeeded(cx,cy,rSun,rMoon,x,y,flux){
    const sep = Math.hypot(x,y);
    // diamond ring: when moon almost covers sun (near contact)
    if (STATE.showDiamond && sep > Math.abs(rSun - rMoon) - 6 && sep < Math.abs(rSun - rMoon) + 6 && flux < 0.15){
      const ang = Math.atan2(y, x);
      const px = cx + x + (rMoon * Math.cos(ang));
      const py = cy + y + (rMoon * Math.sin(ang));
      sky.save();
      sky.beginPath();
      sky.fillStyle = 'rgba(255,255,240,0.98)';
      sky.shadowBlur = 36; sky.shadowColor = '#fff6a8';
      sky.arc(px, py, 10, 0, Math.PI*2);
      sky.fill();
      sky.shadowBlur = 0;
      sky.restore();
    }
    // ring of fire: annular when moon significantly smaller and centered
    if (STATE.showRing && rMoon < rSun && Math.abs(STATE.impact) < 0.18 && Math.abs(sep) < (rSun*0.12)){
      sky.save();
      sky.beginPath();
      sky.lineWidth = 8;
      sky.strokeStyle = 'rgba(246,177,0,0.95)';
      sky.arc(cx,cy,rSun-4,0,Math.PI*2);
      sky.stroke();
      sky.restore();
    }
  }

  // main compute + draw
  function computeStepAndDraw(){
    const u = clamp(STATE.t, 0, 1);
    const {x,y,rSun,rMoon,obscuration,flux,A_overlap,cuUmbra,cuPenumbra,umbra_frac,pen_frac} = computeState(u);
    clearSky();
    const cx = skyC.clientWidth / 2;
    const cy = skyC.clientHeight / 2;
    if (STATE.mode === 'solar'){
      drawSun(cx, cy, rSun);
      drawMoon(cx + x, cy + y, rMoon, '#222');
      if (STATE.guides) drawGuides(cx, cy, rSun, rMoon, x, y, cuUmbra, cuPenumbra);
      drawDiamondRingIfNeeded(cx, cy, rSun, rMoon, x, y, flux);
      sky.fillStyle = '#222'; sky.font = '14px Inter';
      sky.fillText(`t=${(STATE.t*100).toFixed(1)}%  |  Obscuration=${(obscuration*100).toFixed(2)}%  |  Flux=${flux.toFixed(4)}`, 14, 18);
    } else {
      // Lunar mode: draw Earth and shadow cones
      const ex = cx - 120;
      const ey = cy + 30;
      const sunx = cx + 260;
      const suny = cy - 140;
      drawSun(sunx, suny, rSun * 0.6);
      drawEarth(ex, ey, Math.max(48, rSun*0.35));
      // map moon radius rMoon already computed for canvas; get umb/pen radii in canvas
      const moonPhysicalDistance = PHY.d_earth_moon * STATE.moonDistScale;
      const umbPen = umbraPenumbraRadiiAtMoonDistance(moonPhysicalDistance);
      const km2canvas = rMoon / PHY.R_moon;
      const cuUmbra2 = umbPen.r_umbra * km2canvas;
      const cuPenumbra2 = umbPen.r_penumbra * km2canvas;
      const travel = 2.2 * (cuPenumbra2 + rMoon);
      const moonx = ex - travel/2 + travel * u;
      const moony = ey - 200 + (STATE.impact * 80);
      // draw penumbra & umbra
      sky.beginPath(); sky.fillStyle = 'rgba(245,180,80,0.08)'; sky.arc(ex, ey, cuPenumbra2, 0, Math.PI*2); sky.fill();
      sky.beginPath(); sky.fillStyle = 'rgba(40,40,40,0.28)'; sky.arc(ex, ey, cuUmbra2, 0, Math.PI*2); sky.fill();
      drawMoon(moonx, moony, rMoon, '#ddd');
      const dcenter = Math.hypot(moonx - ex, moony - ey);
      const Au = circleOverlapArea(rMoon, cuUmbra2, dcenter);
      const Ap = circleOverlapArea(rMoon, cuPenumbra2, dcenter);
      const penOnly = Math.max(0, Ap - Au);
      const umFrac = Au / (Math.PI * rMoon * rMoon);
      const penFrac = penOnly / (Math.PI * rMoon * rMoon);
      const brightness = 1 - umFrac - penFrac * 0.4;
      sky.fillStyle = '#222'; sky.font = '14px Inter';
      sky.fillText(`t=${(STATE.t*100).toFixed(1)}%  |  Umbra=${(umFrac*100).toFixed(2)}%  Penumbra=${(penFrac*100).toFixed(2)}%  Brightness=${brightness.toFixed(3)}`, 14, 18);
    }
    // push series
    STATE.fluxSeries.push({t: STATE.t, flux: flux});
    STATE.umbraSeries.push({t: STATE.t, umbra: umbra_frac || 0, pen: pen_frac || 0});
    renderFluxPlot();
    renderFractionsPlot();

    if (STATE.t >= 1){
      STATE.running = false; setStatus('Finished');
    }
  }

  // draw Earth stylized
  function drawEarth(cx,cy,r){
    const grad = sky.createRadialGradient(cx - r*0.3, cy - r*0.3, r*0.2, cx, cy, r);
    grad.addColorStop(0, '#bde0ff'); grad.addColorStop(1, '#0b6fa0');
    sky.fillStyle = grad; sky.beginPath(); sky.arc(cx, cy, r, 0, Math.PI*2); sky.fill();
    sky.fillStyle = 'rgba(8,45,68,0.14)';
    sky.beginPath(); sky.ellipse(cx - r*0.15, cy - r*0.06, r*0.4, r*0.18, 0, 0, Math.PI*2); sky.fill();
  }

  // plot renderers
  function renderFluxPlot(){
    const ctx = fluxCtx; const W = fluxC.clientWidth, H = fluxC.clientHeight;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#fffdf4'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#efe7d0'; ctx.beginPath();
    for (let i=0;i<=4;i++){ ctx.moveTo(0,i*H/4); ctx.lineTo(W,i*H/4); } ctx.stroke();
    ctx.fillStyle = '#666'; ctx.font = '12px Inter'; ctx.fillText('Flux (normalized)', 8, 14);
    if (STATE.fluxSeries.length > 1){
      ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = '#f6b100';
      const n = STATE.fluxSeries.length;
      const tmin = STATE.fluxSeries[0].t, tmax = STATE.fluxSeries[n-1].t || 1;
      const sx = t => 8 + ((t - tmin) / Math.max(1e-9,tmax-tmin)) * (W-16);
      const sy = f => 20 + (1 - f) * (H - 36);
      ctx.moveTo(sx(STATE.fluxSeries[0].t), sy(STATE.fluxSeries[0].flux));
      for (let i=1;i<n;i++) ctx.lineTo(sx(STATE.fluxSeries[i].t), sy(STATE.fluxSeries[i].flux));
      ctx.stroke();
    } else {
      ctx.fillStyle = '#999'; ctx.font='12px Inter'; ctx.fillText('Run simulation to generate light curve', 10, H/2);
    }
  }

  function renderFractionsPlot(){
    const ctx = fracCtx; const W = fracC.clientWidth, H = fracC.clientHeight;
    ctx.clearRect(0,0,W,H); ctx.fillStyle = '#fffdf4'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#666'; ctx.font='12px Inter'; ctx.fillText('Umbra (red) / Penumbra (orange)', 8, 14);
    if (STATE.umbraSeries.length > 1){
      const n = STATE.umbraSeries.length;
      const tmin = STATE.umbraSeries[0].t, tmax = STATE.umbraSeries[n-1].t || 1;
      const sx = t => 8 + ((t - tmin) / Math.max(1e-9,tmax-tmin)) * (W-16);
      const sy = v => 20 + (1 - v) * (H - 36);
      ctx.beginPath(); ctx.lineWidth=2; ctx.strokeStyle='#c94a4a';
      ctx.moveTo(sx(STATE.umbraSeries[0].t), sy(STATE.umbraSeries[0].umbra||0));
      for (let i=1;i<n;i++) ctx.lineTo(sx(STATE.umbraSeries[i].t), sy(STATE.umbraSeries[i].umbra||0));
      ctx.stroke();
      ctx.beginPath(); ctx.lineWidth=2; ctx.strokeStyle='#f08c2f';
      ctx.moveTo(sx(STATE.umbraSeries[0].t), sy(STATE.umbraSeries[0].pen||0));
      for (let i=1;i<n;i++) ctx.lineTo(sx(STATE.umbraSeries[i].t), sy(STATE.umbraSeries[i].pen||0));
      ctx.stroke();
    } else {
      ctx.fillStyle = '#999'; ctx.font='12px Inter'; ctx.fillText('Run simulation to compute umbra/penumbra fractions', 10, H/2);
    }
  }

  // loop
  function loop(){
    if (STATE.running){
      const increment = STATE.dt * STATE.speed;
      STATE.t += increment;
      if (STATE.t > 1) STATE.t = 1;
      computeStepAndDraw();
    }
    requestAnimationFrame(loop);
  }
  loop();

  // exports
  function exportSkyPNG(){
    const url = skyC.toDataURL('image/png');
    const a = document.createElement('a'); a.href = url; a.download = `eclipse_${STATE.mode}_${Date.now()}.png`; a.click();
  }

  function exportCSV(){
    if (STATE.fluxSeries.length === 0){ setStatus('No data to export'); return; }
    let csv = 'time,flux,umbra,penumbra\n';
    for (let i=0;i<STATE.fluxSeries.length;i++){
      const t = STATE.fluxSeries[i].t.toFixed(6);
      const flux = STATE.fluxSeries[i].flux.toFixed(6);
      const um = (STATE.umbraSeries[i] && STATE.umbraSeries[i].umbra) ? STATE.umbraSeries[i].umbra.toFixed(6) : '0';
      const pen = (STATE.umbraSeries[i] && STATE.umbraSeries[i].pen) ? STATE.umbraSeries[i].pen.toFixed(6) : '0';
      csv += `${t},${flux},${um},${pen}\n`;
    }
    const blob = new Blob([csv], {type:'text/csv'}); const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `eclipse_data_${STATE.mode}.csv`; a.click();
    URL.revokeObjectURL(url);
    setStatus('CSV exported');
  }

  // drawFrame helper
  function drawFrame(normalizedT){
    STATE.t = clamp(normalizedT,0,1);
    computeStepAndDraw();
  }

  // initializations
  function init(){
    updateDisplayValues();
    resetRun();
    setStatus('Ready');
  }
  init();

  // expose a small API for console debugging
  window.ECLIPSE = { STATE, computeState, computeStepAndDraw, drawFrame, resetRun, exportSkyPNG, exportCSV, applyPreset };

})();
</script>

</body>
</html>
